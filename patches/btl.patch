Author: Alastair McKinstry <mckinstry@debian.org>
Description: Fix by Nathan Hjelm for hangs on 32-bit archs
Bug-Origin: https://github.com/open-mpi/ompi/issues/5638
Last-Updated: 2018-10-08
Forwarded: not-needed

Index: openmpi-3.1.2/opal/mca/btl/vader/btl_vader_fbox.h
===================================================================
--- openmpi-3.1.2.orig/opal/mca/btl/vader/btl_vader_fbox.h
+++ openmpi-3.1.2/opal/mca/btl/vader/btl_vader_fbox.h
@@ -29,6 +29,10 @@ typedef union mca_btl_vader_fbox_hdr_t {
         /** sequence number */
         uint16_t  seq;
     } data;
+    struct {
+        uint32_t value0;
+        uint32_t value1;
+    } data_i32;
     uint64_t ival;
 } mca_btl_vader_fbox_hdr_t;
 
@@ -51,10 +55,23 @@ static inline void mca_btl_vader_fbox_se
                                                   uint16_t seq, uint32_t size)
 {
     mca_btl_vader_fbox_hdr_t tmp = {.data = {.tag = tag, .seq = seq, .size = size}};
+    /* clear out existing tag/seq */
+    hdr->data_i32.value1 = 0;
     opal_atomic_wmb ();
-    hdr->ival = tmp.ival;
+    hdr->data_i32.value0 = size;
+    opal_atomic_wmb ();
+    hdr->data_i32.value1 = tmp.data_i32.value1;
+}
+
+static inline mca_btl_vader_fbox_hdr_t mca_btl_vader_fbox_read_header (mca_btl_vader_fbox_hdr_t *hdr)
+{
+    mca_btl_vader_fbox_hdr_t tmp = {.data_i32 = {.value1 = hdr->data_i32.value1}};;
+    opal_atomic_rmb ();
+    tmp.data_i32.value0 = hdr->data_i32.value0;
+    return tmp;
 }
 
+
 /* attempt to reserve a contiguous segment from the remote ep */
 static inline bool mca_btl_vader_fbox_sendi (mca_btl_base_endpoint_t *ep, unsigned char tag,
                                              void * restrict header, const size_t header_size,
@@ -138,9 +155,6 @@ static inline bool mca_btl_vader_fbox_se
         memcpy (data + header_size, payload, payload_size);
     }
 
-    /* write out part of the header now. the tag will be written when the data is available */
-    mca_btl_vader_fbox_set_header (MCA_BTL_VADER_FBOX_HDR(dst), tag, ep->fbox_out.seq++, data_size);
-
     end += size;
 
     if (OPAL_UNLIKELY(fbox_size == end)) {
@@ -152,6 +166,9 @@ static inline bool mca_btl_vader_fbox_se
         MCA_BTL_VADER_FBOX_HDR(ep->fbox_out.buffer + end)->ival = 0;
     }
 
+    /* write out part of the header now. the tag will be written when the data is available */
+    mca_btl_vader_fbox_set_header (MCA_BTL_VADER_FBOX_HDR(dst), tag, ep->fbox_out.seq++, data_size);
+
     /* align the buffer */
     ep->fbox_out.end = ((uint32_t) hbs << 31) | end;
     opal_atomic_wmb ();
@@ -174,7 +191,7 @@ static inline bool mca_btl_vader_check_f
         int poll_count;
 
         for (poll_count = 0 ; poll_count <= MCA_BTL_VADER_POLL_COUNT ; ++poll_count) {
-            const mca_btl_vader_fbox_hdr_t hdr = {.ival = MCA_BTL_VADER_FBOX_HDR(ep->fbox_in.buffer + start)->ival};
+            const mca_btl_vader_fbox_hdr_t hdr = mca_btl_vader_fbox_read_header (MCA_BTL_VADER_FBOX_HDR(ep->fbox_in.buffer + start));
 
             /* check for a valid tag a sequence number */
             if (0 == hdr.data.tag || hdr.data.seq != ep->fbox_in.seq) {
